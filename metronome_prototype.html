<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimeCraft Metronome</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Professional section-based metronome for intermediate to advanced musicians">
    <meta name="theme-color" content="#764ba2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TimeCraft">
    
    <!-- Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Icons -->
    <link rel="icon" type="image/svg+xml" href="./icon-192.svg">
    <link rel="apple-touch-icon" href="./icon-192.svg">
    <link rel="apple-touch-icon" sizes="192x192" href="./icon-192.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Variables for theming */
        :root {
            --bg-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-panel: rgba(255,255,255,0.1);
            --text-primary: white;
            --text-secondary: rgba(255,255,255,0.8);
            --accent-primary: #4CAF50;
            --accent-secondary: #2196F3;
            --accent-warning: #FF9800;
            --accent-danger: #f44336;
            --border-color: rgba(255,255,255,0.2);
            --shadow-color: rgba(0,0,0,0.3);
        }

        /* Light Theme */
        [data-theme="light"] {
            --bg-primary: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --bg-panel: rgba(255,255,255,0.8);
            --text-primary: #333333;
            --text-secondary: #666666;
            --accent-primary: #4CAF50;
            --accent-secondary: #2196F3;
            --accent-warning: #FF9800;
            --accent-danger: #f44336;
            --border-color: rgba(0,0,0,0.1);
            --shadow-color: rgba(0,0,0,0.2);
        }

        /* High Contrast Theme */
        [data-theme="contrast"] {
            --bg-primary: #000000;
            --bg-panel: #111111;
            --text-primary: #FFFFFF;
            --text-secondary: #CCCCCC;
            --accent-primary: #00FF00;
            --accent-secondary: #0088FF;
            --accent-warning: #FFFF00;
            --accent-danger: #FF0000;
            --border-color: #FFFFFF;
            --shadow-color: rgba(255,255,255,0.3);
        }

        /* Stage Theme (Orange tint for warm stage lighting) */
        [data-theme="stage"] {
            --bg-primary: linear-gradient(135deg, #2D1B13 0%, #4A2C1A 100%);
            --bg-panel: rgba(255,165,0,0.1);
            --text-primary: #FFA500;
            --text-secondary: rgba(255,165,0,0.8);
            --accent-primary: #FF8C00;
            --accent-secondary: #FFB347;
            --accent-warning: #FF6347;
            --accent-danger: #DC143C;
            --border-color: rgba(255,165,0,0.3);
            --shadow-color: rgba(255,140,0,0.3);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .panel h2 {
            margin-bottom: 20px;
            color: var(--text-primary);
            font-size: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapse-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: var(--text-primary);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            min-height: 32px;
        }

        .collapse-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .panel-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .panel.collapsed .panel-content {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .section-builder {
            display: grid;
            gap: 15px;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group label {
            min-width: 80px;
            font-weight: 500;
        }

        input, select, button {
            padding: 12px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            min-height: 44px;
        }

        input, select {
            background: rgba(255,255,255,0.9);
            color: #333;
            flex: 1;
        }

        button {
            background: var(--accent-primary);
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .section-list {
            display: grid;
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .section-item {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .delete-btn {
            background: #f44336;
            padding: 8px 12px;
            font-size: 12px;
            min-height: 36px;
            min-width: 60px;
        }

        .delete-btn:hover {
            background: #d32f2f;
        }

        .arrangement {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            min-height: 60px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 15px;
            border: 2px dashed rgba(255,255,255,0.3);
        }

        .arrangement-item {
            background: #4CAF50;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
            user-select: none;
            position: relative;
        }

        .arrangement-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
            z-index: 1000;
        }

        .arrangement-item.drag-over {
            transform: scale(1.1);
            background: #66BB6A;
            box-shadow: 0 0 20px rgba(102, 187, 106, 0.5);
        }

        .arrangement-item:hover {
            background: #45a049;
            transform: scale(1.05);
        }

        .arrangement-item.current {
            background: #ff9800;
            box-shadow: 0 0 20px rgba(255, 152, 0, 0.5);
        }

        .playback-panel {
            grid-column: 1 / -1;
            text-align: center;
        }

        .transport-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .transport-controls button {
            padding: 20px 35px;
            font-size: 18px;
            border-radius: 15px;
            min-height: 60px;
            min-width: 120px;
        }

        .play-btn {
            background: #4CAF50;
        }

        .status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .status-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .status-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metronome-flash {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            margin: 0 auto 20px;
            transition: all 0.15s ease;
            position: relative;
            border: 3px solid rgba(255,255,255,0.4);
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }

        .metronome-flash::before {
            content: '';
            position: absolute;
            top: -15px;
            left: -15px;
            right: -15px;
            bottom: -15px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            pointer-events: none;
        }

        .metronome-flash.normal {
            width: 50px;
            height: 50px;
        }

        .metronome-flash.large {
            width: 100px;
            height: 100px;
        }

        .metronome-flash.full {
            width: 200px;
            height: 200px;
        }

        .metronome-flash.beat {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.8);
            border-color: rgba(0, 255, 136, 0.6);
            transform: scale(1.1);
        }

        .metronome-flash.beat.accent {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            box-shadow: 0 0 50px rgba(255, 107, 53, 0.9);
            border-color: rgba(255, 107, 53, 0.7);
            transform: scale(1.15);
        }

        .metronome-flash.beat.section-start {
            background: linear-gradient(45deg, #ff3068, #ff6b9d);
            box-shadow: 0 0 60px rgba(255, 48, 104, 1.0);
            border-color: rgba(255, 48, 104, 0.8);
            transform: scale(1.2);
        }

        .metronome-flash.beat.count-in {
            background: linear-gradient(45deg, #ff9800, #ffc107);
            box-shadow: 0 0 35px rgba(255, 152, 0, 0.8);
            border-color: rgba(255, 152, 0, 0.6);
            transform: scale(1.05);
        }

        /* Subdivision dots around metronome */
        .subdivision-indicators {
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -20px;
            border-radius: 50%;
            pointer-events: none;
        }

        .subdivision-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            transition: all 0.2s ease;
        }

        .subdivision-dot.active {
            background: #00ff88;
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
            transform: scale(1.3);
        }

        /* Breathing animation for relaxed feel */
        .metronome-flash.breathing {
            animation: breathe 4s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.7;
            }
            50% { 
                transform: scale(1.1);
                opacity: 0.9;
            }
        }

        /* Faster breathing for high tempos to stay relaxed */
        .metronome-flash.breathing.fast-tempo {
            animation: breathe-fast 2s ease-in-out infinite;
        }

        @keyframes breathe-fast {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.6;
            }
            50% { 
                transform: scale(1.05);
                opacity: 0.8;
            }
        }

        /* Performance Mode Styles */
        .performance-mode .section-builder-panel,
        .performance-mode .arrangement-builder-panel {
            display: none;
        }

        .performance-mode .main-controls {
            grid-template-columns: 1fr;
        }

        .performance-mode .metronome-flash {
            width: 400px !important;
            height: 400px !important;
            margin: 0 auto 30px;
        }

        .performance-mode .status {
            font-size: 1.2em;
        }

        .performance-mode .status-value {
            font-size: 4rem !important;
            font-weight: 900;
        }

        .performance-mode .status-item {
            padding: 25px;
            background: rgba(255,255,255,0.15) !important;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .performance-mode h2 {
            font-size: 2.5rem;
            margin-bottom: 40px;
            text-align: center;
        }

        .performance-mode .transport-controls {
            margin: 40px 0;
        }

        .performance-mode .transport-controls button {
            font-size: 22px;
            padding: 25px 40px;
            min-height: 70px;
            min-width: 140px;
        }

        /* Mobile Portrait Optimizations */
        @media (max-width: 768px) and (orientation: portrait) {
            .main-controls {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .status {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }

            .performance-mode .metronome-flash {
                width: 280px !important;
                height: 280px !important;
            }

            .performance-mode .status-value {
                font-size: 2.5rem !important;
            }

            .performance-mode .transport-controls {
                flex-direction: column;
                gap: 15px;
            }

            .performance-mode .transport-controls button {
                font-size: 18px;
                padding: 18px 30px;
                min-height: 55px;
                width: 100%;
                max-width: 300px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .container {
                padding: 10px;
            }

            body {
                padding: 10px;
            }
        }

        /* Mobile Landscape Optimizations */
        @media (max-width: 768px) and (orientation: landscape) {
            .main-controls {
                grid-template-columns: 1fr;
            }
            
            .status {
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
            }

            .performance-mode .metronome-flash {
                width: 200px !important;
                height: 200px !important;
            }

            .performance-mode .status-value {
                font-size: 2rem !important;
            }

            .performance-mode .status-item {
                padding: 15px 10px;
            }

            .performance-mode .transport-controls button {
                font-size: 16px;
                padding: 15px 25px;
                min-height: 50px;
                min-width: 100px;
            }

            .header h1 {
                font-size: 1.8rem;
                margin-bottom: 5px;
            }

            .header {
                margin-bottom: 20px;
            }
        }

        /* Tablet Portrait */
        @media (min-width: 769px) and (max-width: 1024px) and (orientation: portrait) {
            .performance-mode .metronome-flash {
                width: 350px !important;
                height: 350px !important;
            }

            .performance-mode .status-value {
                font-size: 3.5rem !important;
            }
        }

        /* Hamburger Menu Styles */
        .hamburger-menu {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .hamburger-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .hamburger-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .menu-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .menu-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 300px;
            max-height: calc(100vh - 120px);
            background: rgba(30, 30, 50, 0.95);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1001;
        }

        .menu-panel.active {
            transform: translateX(0);
        }

        .menu-section {
            margin-bottom: 25px;
        }

        .menu-section:last-child {
            margin-bottom: 0;
        }

        .menu-section h3 {
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .menu-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }

        .menu-item label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 500;
        }

        .menu-item select,
        .menu-item button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            min-width: 80px;
        }

        .menu-item button {
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: auto;
            padding: 6px 12px;
        }

        .menu-item button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* Mobile adjustments for hamburger menu */
        @media (max-width: 768px) {
            .hamburger-menu {
                top: 15px;
                right: 15px;
            }

            .hamburger-btn {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }

            .menu-panel {
                top: 70px;
                right: 15px;
                left: 15px;
                width: auto;
                max-height: calc(100vh - 100px);
            }
        }

        /* Small screens general */
        @media (max-width: 768px) {
            .section-builder {
                gap: 12px;
            }

            .input-group {
                flex-direction: column;
                align-items: stretch;
                gap: 5px;
            }

            .input-group label {
                min-width: auto;
                font-size: 14px;
            }

            .transport-controls {
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <!-- Hamburger Menu -->
    <div class="hamburger-menu">
        <button class="hamburger-btn" onclick="toggleMenu()">☰</button>
    </div>

    <!-- Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay" onclick="closeMenu()"></div>

    <!-- Menu Panel -->
    <div class="menu-panel" id="menuPanel">
        <div class="menu-section">
            <h3>Appearance</h3>
            <div class="menu-item">
                <label>Theme:</label>
                <select id="themeSelector">
                    <option value="dark">Dark</option>
                    <option value="light">Light</option>
                    <option value="contrast">High Contrast</option>
                    <option value="stage">Stage</option>
                </select>
            </div>
            <div class="menu-item">
                <label>Visual Size:</label>
                <select id="visualSize">
                    <option value="normal">Normal</option>
                    <option value="large">Large</option>
                    <option value="full">Full</option>
                </select>
            </div>
            <div class="menu-item">
                <label>Performance Mode:</label>
                <button onclick="toggleMode(); closeMenu();" id="modeToggle">📱 Performance</button>
            </div>
        </div>

        <div class="menu-section">
            <h3>Data Management</h3>
            <div class="menu-item">
                <label>Export:</label>
                <button onclick="exportArrangement(); closeMenu();">📤 Export</button>
            </div>
            <div class="menu-item">
                <label>Import:</label>
                <button onclick="document.getElementById('importFile').click(); closeMenu();">📥 Import</button>
            </div>
            <div class="menu-item">
                <label>Templates:</label>
                <button onclick="showTemplates(); closeMenu();">📋 Load</button>
            </div>
            <div class="menu-item">
                <label>Clear All:</label>
                <button onclick="clearAllData(); closeMenu();">🗑️ Clear</button>
            </div>
        </div>

        <div class="menu-section">
            <h3>About</h3>
            <div class="menu-item">
                <label>Version:</label>
                <span style="color: rgba(255,255,255,0.7); font-size: 13px;">TimeCraft v1.0</span>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>🎵 TimeCraft Metronome</h1>
            <p>Program sections, build arrangements, practice with structure</p>
        </div>

        <div class="main-controls">
            <div class="panel section-builder-panel" id="sectionBuilderPanel">
                <h2>Section Builder <button class="collapse-btn" onclick="toggleSectionBuilder()">−</button></h2>

                <div class="panel-content">
                <div class="section-builder">
                    <div class="input-group">
                        <label>Name:</label>
                        <input type="text" id="sectionName" placeholder="A" maxlength="8">
                    </div>
                    <div class="input-group">
                        <label>Tempo:</label>
                        <input type="number" id="sectionTempo" value="120" min="40" max="220">
                        <span>BPM</span>
                    </div>
                    <div class="input-group">
                        <label>Bars:</label>
                        <input type="number" id="sectionBars" value="4" min="1" max="32">
                    </div>
                    <div class="input-group">
                        <label>Time:</label>
                        <input type="number" id="sectionTimeNumerator" value="4" min="1" max="32" style="width: 60px;">
                        <span>/</span>
                        <select id="sectionTimeDenominator" style="width: 60px;">
                            <option value="4" selected>4</option>
                            <option value="8">8</option>
                            <option value="16">16</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Sound:</label>
                        <select id="sectionSound">
                            <option value="classic">Classic (Square)</option>
                            <option value="soft">Soft (Sine)</option>
                            <option value="sharp">Sharp (Sawtooth)</option>
                            <option value="deep">Deep (Triangle)</option>
                            <option value="silent">Silent (Gap Click)</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label style="min-width: auto;">
                            <input type="checkbox" id="accentSectionStart"> Accent section start
                        </label>
                    </div>
                    <div class="input-group">
                        <label style="min-width: auto;">
                            <input type="checkbox" id="swingFeel"> Swing feel (shuffle)
                        </label>
                    </div>
                    <div class="input-group">
                        <label>Subdivision:</label>
                        <select id="sectionSubdivision">
                            <option value="1">Quarter Notes (1)</option>
                            <option value="2">8th Notes (2)</option>
                            <option value="3">Triplets (3)</option>
                            <option value="4">16th Notes (4)</option>
                            <option value="5">Quintuplets (5)</option>
                            <option value="6">16th Triplets (6)</option>
                            <option value="7">Septuplets (7)</option>
                            <option value="8">32nd Notes (8)</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Sub Volume:</label>
                        <input type="range" id="subdivisionVolume" min="0" max="100" value="30">
                        <span id="subdivisionVolumeDisplay">30%</span>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="addSection()" style="flex: 1;">Add Section</button>
                        <button onclick="clearSectionForm()" style="background: #666;">Cancel</button>
                    </div>
                    <div style="margin-top: 10px;">
                        <button onclick="deleteAllSections()" style="background: #f44336; width: 100%;">Delete All Sections</button>
                    </div>
                </div>

                <div class="section-list" id="sectionList">
                    <!-- Sections will be added here -->
                </div>
                </div>
            </div>

            <div class="panel arrangement-builder-panel" id="arrangementBuilderPanel">
                <h2>Arrangement Builder <button class="collapse-btn" onclick="toggleArrangementBuilder()">−</button></h2>
                
                <div class="panel-content">
                <p style="margin-bottom: 15px; opacity: 0.8;">Click sections to add to arrangement:</p>
                
                <div id="availableSections" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                    <!-- Available sections will appear here -->
                </div>

                <div class="arrangement" id="arrangement">
                    <!-- Arrangement will be built here -->
                </div>

                <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                    <button onclick="clearArrangement()" style="background: #f44336;">Clear Arrangement</button>
                    <button onclick="loadPreset('verse-chorus')">Verse-Chorus</button>
                    <button onclick="loadPreset('drum-groove')">Drum Groove</button>
                    <button onclick="loadPreset('fill-practice')">Fill Practice</button>
                    <button onclick="loadPreset('tempo-build')">Tempo Build</button>
                    <button onclick="loadPreset('limb-independence')">Limb Independence</button>
                    <button onclick="loadPreset('gap-click')">Gap Click</button>
                    <button onclick="loadPreset('gap-click-short')">Gap Click Short</button>
                    <button onclick="loadPreset('swing-practice')">Swing Practice</button>
                </div>
                
                <div style="display: flex; flex-wrap: wrap; gap: 10px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px;">
                    <button onclick="saveArrangement()" style="background: #4CAF50;">💾 Save</button>
                    <button onclick="loadArrangement()" style="background: #2196F3;">📁 Load</button>
                    <button onclick="exportArrangement()" style="background: #FF9800;">📤 Export</button>
                    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importArrangement(event)">
                    <button onclick="document.getElementById('importFile').click()" style="background: #9C27B0;">📥 Import</button>
                </div>
                </div>
            </div>
        </div>

        <div class="panel playback-panel">
            <h2>Playback Control</h2>
            
            
            <div class="metronome-flash" id="metronomeFlash">
                <div class="subdivision-indicators" id="subdivisionIndicators">
                    <!-- Subdivision dots will be added here dynamically -->
                </div>
            </div>
            
            <div class="transport-controls">
                <button class="play-btn" onclick="togglePlayback()" id="playButton">▶ PLAY</button>
                <button onclick="tapTempo()" id="tapButton" style="background: #9C27B0;">🎯 TAP TEMPO</button>
            </div>

            <div style="display: flex; justify-content: center; gap: 30px; margin: 20px 0; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: 600;">Main Volume:</label>
                    <input type="range" id="globalMainVolume" min="0" max="100" value="70" style="width: 120px;">
                    <span id="globalMainVolumeDisplay" style="min-width: 35px; font-weight: 600;">70%</span>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: 600;">Sub Volume:</label>
                    <input type="range" id="globalSubVolume" min="0" max="100" value="30" style="width: 120px;">
                    <span id="globalSubVolumeDisplay" style="min-width: 35px; font-weight: 600;">30%</span>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: 600;">Count-in:</label>
                    <select id="countInBars" style="width: 80px;">
                        <option value="0" selected>Off</option>
                        <option value="1">1 Bar</option>
                        <option value="2">2 Bars</option>
                        <option value="3">3 Bars</option>
                        <option value="4">4 Bars</option>
                    </select>
                </div>
            </div>

            <div class="status">
                <div class="status-item">
                    <div class="status-value" id="currentSection">--</div>
                    <div>Current Section</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="currentTempo">--</div>
                    <div>BPM</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="currentBar">--</div>
                    <div>Bar</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="currentBeat">--</div>
                    <div>Beat</div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);">
                <div style="font-size: 13px; opacity: 0.9; margin-bottom: 6px; font-weight: 500;">Upcoming Section</div>
                <div id="upcomingSection" style="font-size: 14px; font-weight: 600; line-height: 1.3; word-break: break-word;">--</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let sections = {};
        let arrangement = [];
        let isPlaying = false;
        let audioContext;
        let currentArrangementIndex = 0;
        let currentBar = 1;
        let currentBeat = 1;
        // Track what's actually playing now (for display) vs what's being scheduled next
        let playingArrangementIndex = 0;
        let playingBar = 1;
        let playingBeat = 1;
        let nextBeatTime = 0;
        let schedulerTimer;
        let lookahead = 25.0; // milliseconds
        let scheduleAheadTime = 0.1; // seconds
        let globalMainVolume = 70; // Global main volume percentage
        let globalSubVolume = 30; // Global subdivision volume percentage
        let editingSection = null; // Track which section is being edited
        let visualSize = 'normal'; // Visual metronome size
        let tapTimes = []; // Store tap timestamps for tempo calculation
        let tapTimeout = null; // Reset taps after inactivity
        let countInBars = 0; // Number of count-in bars
        let isCountingIn = false; // Track if we're in count-in phase
        let countInBar = 1; // Current count-in bar
        let countInBeat = 1; // Current count-in beat
        let isPerformanceMode = false; // Track interface mode

        // Simple delete function - exposed globally
        window.deleteSectionByName = function(sectionName) {
            console.log('Attempting to delete:', sectionName);
            if (confirm(`Delete section "${sectionName}"?`)) {
                console.log('User confirmed deletion');
                delete sections[sectionName];
                // Remove from arrangement
                arrangement = arrangement.filter(section => section !== sectionName);
                console.log('Updated sections:', Object.keys(sections));
                updateSectionDisplay();
                updateAvailableSections();
                updateArrangementDisplay();
                autoSave(); // Auto-save after deleting section
            }
        };

        // Delete all sections function
        function deleteAllSections() {
            const sectionCount = Object.keys(sections).length;
            if (sectionCount === 0) {
                alert('No sections to delete.');
                return;
            }
            
            if (confirm(`Delete all ${sectionCount} sections? This will also clear the arrangement.`)) {
                sections = {};
                arrangement = [];
                currentArrangementIndex = 0;
                
                updateSectionDisplay();
                updateAvailableSections();
                updateArrangementDisplay();
                updateStatus();
                autoSave(); // Auto-save after deleting all sections
                
                alert('All sections deleted successfully.');
            }
        }

        // Edit section function - exposed globally
        window.editSectionByName = function(sectionName) {
            const section = sections[sectionName];
            if (!section) return;

            editingSection = sectionName;
            
            // Populate form with current values
            document.getElementById('sectionName').value = sectionName;
            document.getElementById('sectionTempo').value = section.tempo;
            document.getElementById('sectionBars').value = section.bars;
            
            const [numerator, denominator] = section.timeSignature.split('/');
            document.getElementById('sectionTimeNumerator').value = numerator;
            document.getElementById('sectionTimeDenominator').value = denominator;
            
            document.getElementById('sectionSubdivision').value = section.subdivision || 1;
            document.getElementById('subdivisionVolume').value = section.subdivisionVolume || 30;
            document.getElementById('subdivisionVolumeDisplay').textContent = (section.subdivisionVolume || 30) + '%';
            document.getElementById('sectionSound').value = section.sound || 'classic';
            document.getElementById('accentSectionStart').checked = section.accentSectionStart || false;
            document.getElementById('swingFeel').checked = section.swingFeel || false;
            
            // Update button text
            document.querySelector('button[onclick="addSection()"]').textContent = 'Update Section';
            
            // Scroll to section builder
            document.querySelector('.section-builder').scrollIntoView({ behavior: 'smooth' });
        };

        // Initialize audio context on first user interaction
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // Get sound settings based on sound type
        function getSoundSettings(soundType, isAccent, isSubdivision, isSectionStart) {
            const settings = {
                classic: {
                    waveform: 'square',
                    frequencies: { accent: 1000, beat: 800, subdivision: 600, sectionStart: 1200 }
                },
                soft: {
                    waveform: 'sine', 
                    frequencies: { accent: 880, beat: 660, subdivision: 440, sectionStart: 1100 }
                },
                sharp: {
                    waveform: 'sawtooth',
                    frequencies: { accent: 1200, beat: 900, subdivision: 700, sectionStart: 1400 }
                },
                deep: {
                    waveform: 'triangle',
                    frequencies: { accent: 400, beat: 300, subdivision: 200, sectionStart: 500 }
                }
            };

            const soundConfig = settings[soundType] || settings.classic;
            
            let frequency;
            if (isSectionStart) {
                frequency = soundConfig.frequencies.sectionStart;
            } else if (isAccent) {
                frequency = soundConfig.frequencies.accent;
            } else if (isSubdivision) {
                frequency = soundConfig.frequencies.subdivision;
            } else {
                frequency = soundConfig.frequencies.beat;
            }

            return {
                waveform: soundConfig.waveform,
                frequency: frequency
            };
        }

        // Create a click sound with different tones for subdivisions
        function playClick(time, accent = false, subdivision = false, soundType = 'classic', isSectionStart = false) {
            if (!audioContext) return;
            
            // Silent sections: provide visual feedback only, no audio
            if (soundType === 'silent') {
                // Visual feedback - flash for main beats and section starts in silent mode
                if (Math.abs(time - audioContext.currentTime) < 0.1) {
                    const flash = document.getElementById('metronomeFlash');
                    if (!subdivision) {
                        flash.classList.add('beat');
                        // Use different flash duration for silent mode to indicate it's silent
                        flash.style.backgroundColor = '#ff6b6b'; // Different color for silent
                        setTimeout(() => {
                            flash.classList.remove('beat');
                            flash.style.backgroundColor = ''; // Reset color
                        }, isSectionStart ? 200 : 100);
                    }
                }
                return; // No audio output for silent sections
            }
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Get sound settings
            const soundSettings = getSoundSettings(soundType, accent, subdivision, isSectionStart);
            oscillator.frequency.value = soundSettings.frequency;
            oscillator.type = soundSettings.waveform;
            
            // Volume based on click type - use global volumes
            let volume = 0.1;
            if (subdivision) {
                volume = 0.1 * (globalSubVolume / 100);
            } else if (isSectionStart) {
                volume = 0.15 * (globalMainVolume / 100); // Section start uses main volume
            } else {
                volume = 0.1 * (globalMainVolume / 100); // Regular beats use main volume
            }
            
            // Duration based on sound type and click type
            let duration = isSectionStart ? 0.15 : (subdivision ? 0.04 : 0.08);
            
            gainNode.gain.setValueAtTime(volume, time);
            gainNode.gain.exponentialRampToValueAtTime(0.01, time + duration);
            
            oscillator.start(time);
            oscillator.stop(time + duration);

            // Enhanced visual feedback with color coding
            if (Math.abs(time - audioContext.currentTime) < 0.1) {
                const flash = document.getElementById('metronomeFlash');
                if (!subdivision) {
                    // Remove any existing beat classes
                    flash.classList.remove('beat', 'accent', 'section-start');
                    
                    // Add appropriate classes
                    flash.classList.add('beat');
                    if (isSectionStart) {
                        flash.classList.add('section-start');
                    } else if (accent) {
                        flash.classList.add('accent');
                    }
                    
                    // Longer flash duration for better visibility
                    setTimeout(() => {
                        flash.classList.remove('beat', 'accent', 'section-start');
                    }, isSectionStart ? 300 : (accent ? 200 : 150));
                }
                
                // Update subdivision indicators
                updateSubdivisionIndicators(subdivision, false);
            }
        }

        // Create count-in click sound (higher pitch and shorter than regular clicks)
        function playCountInClick(time, accent = false) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Count-in uses a higher pitched sine wave for distinction
            oscillator.frequency.value = accent ? 1400 : 1200; // Higher than regular accent tones
            oscillator.type = 'sine';
            
            // Volume - slightly quieter than main beats
            let volume = 0.08 * (globalMainVolume / 100);
            if (accent) volume *= 1.3; // Accent is slightly louder
            
            // Shorter duration for count-in
            let duration = 0.06;
            
            gainNode.gain.setValueAtTime(volume, time);
            gainNode.gain.exponentialRampToValueAtTime(0.01, time + duration);
            
            oscillator.start(time);
            oscillator.stop(time + duration);

            // Enhanced visual feedback for count-in
            if (Math.abs(time - audioContext.currentTime) < 0.1) {
                const flash = document.getElementById('metronomeFlash');
                flash.classList.add('beat', 'count-in');
                setTimeout(() => {
                    flash.classList.remove('beat', 'count-in');
                }, 200); // Longer flash duration
            }
        }

        // Parse time signature
        function parseTimeSignature(timeSig) {
            const [numerator, denominator] = timeSig.split('/').map(Number);
            return { numerator, denominator };
        }

        // Calculate beat duration based on tempo and time signature
        function getBeatDuration(tempo, timeSig) {
            const { denominator } = parseTimeSignature(timeSig);
            return 60.0 / tempo * (4 / denominator);
        }

        // Schedule the next beat with subdivisions
        function scheduler() {
            if (!isPlaying || arrangement.length === 0) return;

            while (nextBeatTime < audioContext.currentTime + scheduleAheadTime) {
                // Handle count-in phase
                if (isCountingIn) {
                    // Use first section's tempo and time signature for count-in
                    const firstSectionName = arrangement[0];
                    const firstSectionData = sections[firstSectionName];
                    
                    if (!firstSectionData) {
                        stopPlayback();
                        return;
                    }
                    
                    const timeSig = parseTimeSignature(firstSectionData.timeSignature);
                    const baseBeatDuration = getBeatDuration(firstSectionData.tempo, firstSectionData.timeSignature);
                    
                    // Schedule count-in click
                    const isAccent = countInBeat === 1; // Accent on beat 1 of each count-in bar
                    playCountInClick(nextBeatTime, isAccent);
                    
                    // Move to next beat
                    nextBeatTime += baseBeatDuration;
                    countInBeat++;
                    
                    if (countInBeat > timeSig.numerator) {
                        countInBeat = 1;
                        countInBar++;
                        
                        if (countInBar > countInBars) {
                            // Count-in complete, start main arrangement
                            isCountingIn = false;
                            currentArrangementIndex = 0;
                            currentBar = 1;
                            currentBeat = 1;
                            updateArrangementDisplay();
                        }
                    }
                    
                    updateStatus();
                    continue; // Skip regular scheduling logic during count-in
                }

                const currentSectionName = arrangement[currentArrangementIndex];
                const currentSectionData = sections[currentSectionName];
                
                if (!currentSectionData) {
                    stopPlayback();
                    return;
                }

                const timeSig = parseTimeSignature(currentSectionData.timeSignature);
                const subdivision = currentSectionData.subdivision || 1;
                const soundType = currentSectionData.sound || 'classic';
                const accentSectionStart = currentSectionData.accentSectionStart || false;
                const swingFeel = currentSectionData.swingFeel || false;
                
                // Calculate subdivision timing
                const baseBeatDuration = getBeatDuration(currentSectionData.tempo, currentSectionData.timeSignature);
                
                // Check if this is the very first beat of a new section
                const isSectionStart = accentSectionStart && currentBar === 1 && currentBeat === 1;
                
                // Update "currently playing" variables when beat is about to play
                if (Math.abs(nextBeatTime - audioContext.currentTime) < 0.1) {
                    playingArrangementIndex = currentArrangementIndex;
                    playingBar = currentBar;
                    playingBeat = currentBeat;
                    // Update status and arrangement display when playing variables change
                    updateStatus();
                    updateArrangementDisplay();
                }

                // Schedule main beat (always plays)
                const isMainBeatAccent = currentBeat === 1 && !isSectionStart; // Don't double-accent
                playClick(nextBeatTime, isMainBeatAccent, false, soundType, isSectionStart);
                
                // Schedule subdivision clicks (if subdivision > 1 OR swing with quarters)
                if (subdivision > 1 || (swingFeel && subdivision === 1)) {
                    if (swingFeel) {
                        // Swing timing: use triplet feel
                        // Play on 1st and 3rd of triplet (long-short pattern)
                        const tripletDuration = baseBeatDuration / 3;
                        
                        if (subdivision === 1) {
                            // Swing quarters: add swing 8th notes
                            const secondNoteTime = nextBeatTime + (tripletDuration * 2);
                            playClick(secondNoteTime, false, true, soundType, false);
                        } else {
                            // For subdivision > 1, apply swing to pairs
                            const swingSubdivisions = Math.floor(subdivision / 2);
                            for (let swingPair = 0; swingPair < swingSubdivisions; swingPair++) {
                                // First note of swing pair (long note - on triplet beat 1)
                                const firstNoteTime = nextBeatTime + (baseBeatDuration * 2 * swingPair / subdivision);
                                playClick(firstNoteTime, false, true, soundType, false);
                                
                                // Second note of swing pair (short note - on triplet beat 3)
                                const secondNoteTime = firstNoteTime + (tripletDuration * 2);
                                playClick(secondNoteTime, false, true, soundType, false);
                            }
                            
                            // Handle odd subdivisions (play remaining straight)
                            if (subdivision % 2 === 1 && subdivision > 2) {
                                const lastSubdivisionTime = nextBeatTime + (baseBeatDuration * (subdivision - 1) / subdivision);
                                playClick(lastSubdivisionTime, false, true, soundType, false);
                            }
                        }
                    } else {
                        // Regular straight timing
                        const subdivisionDuration = baseBeatDuration / subdivision;
                        for (let sub = 1; sub < subdivision; sub++) {
                            const subdivisionTime = nextBeatTime + (subdivisionDuration * sub);
                            playClick(subdivisionTime, false, true, soundType, false);
                        }
                    }
                }
                
                // Move to next beat
                nextBeatTime += baseBeatDuration;
                
                // Advance beat/bar/section
                currentBeat++;
                if (currentBeat > timeSig.numerator) {
                    currentBeat = 1;
                    currentBar++;
                    
                    if (currentBar > currentSectionData.bars) {
                        currentBar = 1;
                        currentArrangementIndex++;
                        
                        if (currentArrangementIndex >= arrangement.length) {
                            currentArrangementIndex = 0; // Loop arrangement
                        }
                    }
                }
            }
        }

        // Update status display
        function updateStatus() {
            if (arrangement.length === 0) {
                document.getElementById('currentTempo').textContent = '--';
                document.getElementById('currentSection').textContent = '--';
                document.getElementById('currentBar').textContent = '--';
                document.getElementById('currentBeat').textContent = '--';
                document.getElementById('upcomingSection').textContent = '--';
                return;
            }

            if (isCountingIn) {
                // Show count-in status
                const firstSectionName = arrangement[0];
                const firstSectionData = sections[firstSectionName];
                
                if (firstSectionData) {
                    document.getElementById('currentTempo').textContent = firstSectionData.tempo;
                    document.getElementById('currentSection').textContent = 'COUNT-IN';
                    document.getElementById('currentBar').textContent = `${countInBar}/${countInBars}`;
                    document.getElementById('currentBeat').textContent = countInBeat;
                    
                    // Show detailed upcoming section info during count-in
                    const subdivisionText = getSubdivisionText(firstSectionData.subdivision || 1);
                    document.getElementById('upcomingSection').textContent = `${firstSectionName} - ${firstSectionData.tempo}BPM - ${firstSectionData.timeSignature} - ${subdivisionText}`;
                }
            } else {
                // Show currently playing status (not what's being scheduled)
                const playingSectionName = arrangement[playingArrangementIndex];
                const playingSectionData = sections[playingSectionName];
                
                if (playingSectionData) {
                    document.getElementById('currentTempo').textContent = playingSectionData.tempo;
                    document.getElementById('currentSection').textContent = playingSectionName;
                    document.getElementById('currentBar').textContent = `${playingBar}/${playingSectionData.bars}`;
                    document.getElementById('currentBeat').textContent = playingBeat;
                    
                    // Calculate and show upcoming section
                    const upcomingSectionName = getUpcomingSection();
                    document.getElementById('upcomingSection').textContent = upcomingSectionName || '--';
                }
            }
        }

        // Calculate what section is coming next
        function getUpcomingSection() {
            if (!isPlaying || arrangement.length === 0) return null;
            
            // Always show the next section in the arrangement (what comes after current section)
            let nextIndex = currentArrangementIndex + 1;
            if (nextIndex >= arrangement.length) {
                nextIndex = 0; // Loop back to beginning
            }
            
            const upcomingSectionName = arrangement[nextIndex];
            
            // Get section details
            const upcomingSectionData = sections[upcomingSectionName];
            if (!upcomingSectionData) return upcomingSectionName;
            
            const subdivisionText = getSubdivisionText(upcomingSectionData.subdivision || 1);
            return `${upcomingSectionName} - ${upcomingSectionData.tempo}BPM - ${upcomingSectionData.timeSignature} - ${subdivisionText}`;
        }

        // Add or update section
        function addSection() {
            const name = document.getElementById('sectionName').value.trim();
            const tempo = parseInt(document.getElementById('sectionTempo').value);
            const bars = parseInt(document.getElementById('sectionBars').value);
            const timeNumerator = parseInt(document.getElementById('sectionTimeNumerator').value);
            const timeDenominator = parseInt(document.getElementById('sectionTimeDenominator').value);
            const timeSignature = `${timeNumerator}/${timeDenominator}`;
            const subdivision = parseInt(document.getElementById('sectionSubdivision').value);
            const subdivisionVolume = parseInt(document.getElementById('subdivisionVolume').value);
            const sound = document.getElementById('sectionSound').value;
            const accentSectionStart = document.getElementById('accentSectionStart').checked;
            const swingFeel = document.getElementById('swingFeel').checked;

            if (!name) {
                alert('Please enter a section name');
                return;
            }

            // If editing, update existing section
            if (editingSection) {
                // If name changed, need to handle arrangement updates
                if (editingSection !== name) {
                    // Update arrangement with new name
                    arrangement = arrangement.map(sectionName => 
                        sectionName === editingSection ? name : sectionName
                    );
                    // Delete old section
                    delete sections[editingSection];
                }
                editingSection = null;
                document.querySelector('button[onclick="addSection()"]').textContent = 'Add Section';
            } else if (sections[name]) {
                if (!confirm(`Section "${name}" already exists. Replace it?`)) {
                    return;
                }
            }

            sections[name] = { 
                tempo, 
                bars, 
                timeSignature, 
                subdivision, 
                subdivisionVolume,
                sound,
                accentSectionStart,
                swingFeel
            };
            
            // Clear inputs
            clearSectionForm();
            
            updateSectionDisplay();
            updateAvailableSections();
            updateArrangementDisplay();
            autoSave(); // Auto-save after adding/updating section
        }

        // Clear section form
        function clearSectionForm() {
            document.getElementById('sectionName').value = '';
            document.getElementById('sectionTempo').value = '120';
            document.getElementById('sectionBars').value = '4';
            document.getElementById('sectionTimeNumerator').value = '4';
            document.getElementById('sectionTimeDenominator').value = '4';
            document.getElementById('sectionSubdivision').value = '1';
            document.getElementById('subdivisionVolume').value = '30';
            document.getElementById('subdivisionVolumeDisplay').textContent = '30%';
            document.getElementById('sectionSound').value = 'classic';
            document.getElementById('accentSectionStart').checked = false;
            document.getElementById('swingFeel').checked = false;
            editingSection = null;
            document.querySelector('button[onclick="addSection()"]').textContent = 'Add Section';
        }

        // Update section list display - SIMPLIFIED
        function updateSectionDisplay() {
            const container = document.getElementById('sectionList');
            container.innerHTML = '';

            Object.entries(sections).forEach(([name, data]) => {
                const div = document.createElement('div');
                div.className = 'section-item';
                const subdivisionText = getSubdivisionText(data.subdivision || 1);
                const soundText = getSoundText(data.sound || 'classic');
                const accentText = data.accentSectionStart ? ', Section Accent' : '';
                const swingText = data.swingFeel ? ', Swing' : '';
                
                // Create content span
                const contentSpan = document.createElement('span');
                contentSpan.innerHTML = `<strong>${name}</strong>: ${data.tempo}bpm, ${data.bars} bars, ${data.timeSignature}, ${subdivisionText}, ${soundText}${accentText}${swingText}`;
                
                // Create button container
                const buttonContainer = document.createElement('div');
                buttonContainer.style.display = 'flex';
                buttonContainer.style.gap = '5px';
                
                // Create edit button
                const editButton = document.createElement('button');
                editButton.style.background = '#2196F3';
                editButton.style.padding = '8px 12px';
                editButton.style.fontSize = '12px';
                editButton.style.minHeight = '36px';
                editButton.style.minWidth = '50px';
                editButton.textContent = 'Edit';
                editButton.onclick = () => editSectionByName(name);
                
                // Create delete button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-btn';
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => deleteSectionByName(name);
                
                buttonContainer.appendChild(editButton);
                buttonContainer.appendChild(deleteButton);
                
                div.appendChild(contentSpan);
                div.appendChild(buttonContainer);
                container.appendChild(div);
            });
        }

        // Helper function to get subdivision text
        function getSubdivisionText(subdivision) {
            const subdivisionMap = {
                1: 'Quarter Notes',
                2: '8th Notes', 
                3: 'Triplets',
                4: '16th Notes',
                5: 'Quintuplets',
                6: '16th Triplets',
                7: 'Septuplets',
                8: '32nd Notes'
            };
            return subdivisionMap[subdivision] || 'Quarter Notes';
        }

        // Helper function to get sound text
        function getSoundText(sound) {
            const soundMap = {
                'classic': 'Classic',
                'soft': 'Soft',
                'sharp': 'Sharp',
                'deep': 'Deep',
                'silent': 'Silent'
            };
            return soundMap[sound] || 'Classic';
        }

        // Update visual metronome size and animation
        function updateVisualMetronome() {
            const flash = document.getElementById('metronomeFlash');
            const currentTempo = getCurrentTempo();
            
            // Remove existing size classes
            flash.classList.remove('normal', 'large', 'full');
            
            // Add current size class
            flash.classList.add(visualSize);
            
            // Add breathing animation only when playing
            if (isPlaying) {
                flash.classList.add('breathing');
                
                // Adjust breathing speed based on tempo
                if (currentTempo && currentTempo > 160) {
                    flash.classList.add('fast-tempo');
                } else {
                    flash.classList.remove('fast-tempo');
                }
            }
            
            // Update subdivision indicators for current section
            if (isPlaying && arrangement.length > 0) {
                const currentSectionName = arrangement[currentArrangementIndex];
                const currentSectionData = sections[currentSectionName];
                if (currentSectionData) {
                    createSubdivisionIndicators(currentSectionData.subdivision || 1);
                }
            } else {
                createSubdivisionIndicators(1); // Default to quarter notes when not playing
            }
        }

        // Create subdivision indicator dots around metronome
        function createSubdivisionIndicators(subdivision) {
            const container = document.getElementById('subdivisionIndicators');
            container.innerHTML = '';
            
            // Don't show dots for quarter notes (subdivision = 1)
            if (subdivision <= 1) return;
            
            const radius = 60; // Distance from center
            const totalDots = subdivision;
            
            for (let i = 0; i < totalDots; i++) {
                const dot = document.createElement('div');
                dot.className = 'subdivision-dot';
                dot.id = `subdivision-dot-${i}`;
                
                // Calculate position around circle (starting at top, going clockwise)
                const angle = (i * 360 / totalDots - 90) * (Math.PI / 180); // -90 to start at top
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                
                dot.style.left = `calc(50% + ${x}px - 4px)`;
                dot.style.top = `calc(50% + ${y}px - 4px)`;
                
                container.appendChild(dot);
            }
        }

        // Update subdivision indicators to show current subdivision beat
        function updateSubdivisionIndicators(subdivision, isSubdivision) {
            if (subdivision <= 1) return;
            
            // Clear all active dots
            const dots = document.querySelectorAll('.subdivision-dot');
            dots.forEach(dot => dot.classList.remove('active'));
            
            if (isSubdivision) {
                // Light up subdivision dots sequentially
                // This would need more complex logic to track which subdivision we're on
                // For now, just show a brief flash
                dots.forEach((dot, index) => {
                    setTimeout(() => {
                        dot.classList.add('active');
                        setTimeout(() => dot.classList.remove('active'), 100);
                    }, index * 20);
                });
            }
        }

        // Get current tempo from active section
        function getCurrentTempo() {
            if (arrangement.length === 0 || !isPlaying) return null;
            const currentSectionName = arrangement[currentArrangementIndex];
            const currentSectionData = sections[currentSectionName];
            return currentSectionData ? currentSectionData.tempo : null;
        }

        // Tap tempo functionality
        function tapTempo() {
            const now = Date.now();
            tapTimes.push(now);
            
            // Clear existing timeout
            if (tapTimeout) {
                clearTimeout(tapTimeout);
            }
            
            // Reset taps after 3 seconds of inactivity
            tapTimeout = setTimeout(() => {
                tapTimes = [];
                updateTapTempoDisplay('Tap to set tempo');
            }, 3000);
            
            // Need at least 2 taps to calculate tempo
            if (tapTimes.length >= 2) {
                const intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i-1]);
                }
                
                // Calculate average interval in milliseconds
                const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;
                
                // Convert to BPM (60000ms per minute)
                const bpm = Math.round(60000 / avgInterval);
                
                // Clamp to reasonable range
                const clampedBpm = Math.max(40, Math.min(220, bpm));
                
                updateTapTempoDisplay(`${clampedBpm} BPM (${tapTimes.length} taps)`);
                
                // After 3+ taps, suggest applying the tempo
                if (tapTimes.length >= 3) {
                    // Add apply button or auto-apply after a moment
                    setTimeout(() => {
                        if (confirm(`Apply tempo ${clampedBpm} BPM to current section?`)) {
                            applyTapTempo(clampedBpm);
                        }
                    }, 500);
                }
            } else {
                updateTapTempoDisplay('Tap again...');
            }
            
            // Limit stored taps to last 8 for better accuracy
            if (tapTimes.length > 8) {
                tapTimes = tapTimes.slice(-8);
            }
        }

        // Update tap tempo display
        function updateTapTempoDisplay(text) {
            const button = document.getElementById('tapButton');
            button.innerHTML = `🎯 ${text}`;
        }

        // Apply detected tempo to the current section being edited or first section
        function applyTapTempo(bpm) {
            if (editingSection && sections[editingSection]) {
                // Apply to section being edited
                sections[editingSection].tempo = bpm;
                document.getElementById('sectionTempo').value = bpm;
                updateSectionDisplay();
                tapTimes = [];
                updateTapTempoDisplay('Applied! Tap to set tempo');
            } else if (Object.keys(sections).length > 0) {
                // Apply to first section if no section is being edited
                const firstSection = Object.keys(sections)[0];
                sections[firstSection].tempo = bpm;
                updateSectionDisplay();
                tapTimes = [];
                updateTapTempoDisplay('Applied! Tap to set tempo');
            } else {
                // Create a new section with the tapped tempo
                document.getElementById('sectionTempo').value = bpm;
                tapTimes = [];
                updateTapTempoDisplay('Tempo set! Tap to set tempo');
            }
        }

        // Save/Load functionality
        function saveArrangement() {
            const arrangementName = prompt('Enter a name for this arrangement:', 'My Arrangement');
            if (!arrangementName) return;
            
            const data = {
                name: arrangementName,
                sections: sections,
                arrangement: arrangement,
                timestamp: new Date().toISOString()
            };
            
            // Save to localStorage
            const savedArrangements = JSON.parse(localStorage.getItem('timecraft_arrangements') || '{}');
            savedArrangements[arrangementName] = data;
            localStorage.setItem('timecraft_arrangements', JSON.stringify(savedArrangements));
            
            alert(`Arrangement "${arrangementName}" saved successfully!`);
        }

        function loadArrangement() {
            const savedArrangements = JSON.parse(localStorage.getItem('timecraft_arrangements') || '{}');
            const arrangementNames = Object.keys(savedArrangements);
            
            if (arrangementNames.length === 0) {
                alert('No saved arrangements found.');
                return;
            }
            
            // Create selection dialog
            let selection = 'Choose an arrangement to load:\n\n';
            arrangementNames.forEach((name, index) => {
                const timestamp = new Date(savedArrangements[name].timestamp).toLocaleString();
                selection += `${index + 1}. ${name} (saved: ${timestamp})\n`;
            });
            
            const choice = prompt(selection + '\nEnter the number of the arrangement to load:');
            const choiceIndex = parseInt(choice) - 1;
            
            if (choiceIndex >= 0 && choiceIndex < arrangementNames.length) {
                const selectedName = arrangementNames[choiceIndex];
                const data = savedArrangements[selectedName];
                
                // Load the arrangement
                sections = data.sections;
                arrangement = data.arrangement;
                
                updateSectionDisplay();
                updateAvailableSections();
                updateArrangementDisplay();
                updateStatus();
                
                alert(`Arrangement "${selectedName}" loaded successfully!`);
            }
        }

        function exportArrangement() {
            const arrangementName = prompt('Enter a name for the export file:', 'TimeCraft-Arrangement');
            if (!arrangementName) return;
            
            const data = {
                name: arrangementName,
                sections: sections,
                arrangement: arrangement,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };
            
            // Create download
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${arrangementName}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importArrangement(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate data structure
                    if (!data.sections || !data.arrangement) {
                        alert('Invalid arrangement file format.');
                        return;
                    }
                    
                    // Load the arrangement
                    sections = data.sections;
                    arrangement = data.arrangement;
                    
                    updateSectionDisplay();
                    updateAvailableSections();
                    updateArrangementDisplay();
                    updateStatus();
                    
                    alert(`Arrangement "${data.name || 'Imported'}" loaded successfully!`);
                } catch (error) {
                    alert('Error reading arrangement file. Please check the file format.');
                }
            };
            reader.readAsText(file);
            
            // Clear the input so the same file can be selected again
            event.target.value = '';
        }

        // Auto-save current state periodically
        function autoSave() {
            if (Object.keys(sections).length > 0 || arrangement.length > 0) {
                const data = {
                    sections: sections,
                    arrangement: arrangement,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('timecraft_autosave', JSON.stringify(data));
            }
        }

        // Auto-load last state on startup
        function autoLoad() {
            const autoSaveData = localStorage.getItem('timecraft_autosave');
            if (autoSaveData) {
                try {
                    const data = JSON.parse(autoSaveData);
                    // Only auto-load if current state is empty
                    if (Object.keys(sections).length === 0 && arrangement.length === 0) {
                        sections = data.sections || {};
                        arrangement = data.arrangement || [];
                    }
                } catch (error) {
                    console.log('Could not load auto-save data');
                }
            }
        }

        // Update available sections for arrangement building
        function updateAvailableSections() {
            const container = document.getElementById('availableSections');
            container.innerHTML = '';

            Object.keys(sections).forEach(name => {
                const button = document.createElement('button');
                button.textContent = name;
                button.onclick = () => addToArrangement(name);
                button.style.background = '#2196F3';
                button.style.minHeight = '44px';
                button.style.minWidth = '44px';
                button.style.padding = '12px 16px';
                container.appendChild(button);
            });
        }

        // Add section to arrangement
        function addToArrangement(sectionName) {
            arrangement.push(sectionName);
            updateArrangementDisplay();
            autoSave(); // Auto-save after modifying arrangement
        }

        // Update arrangement display with drag & drop support
        function updateArrangementDisplay() {
            const container = document.getElementById('arrangement');
            container.innerHTML = '';

            arrangement.forEach((sectionName, index) => {
                const div = document.createElement('div');
                div.className = 'arrangement-item';
                if (index === playingArrangementIndex && isPlaying && !isCountingIn) {
                    div.classList.add('current');
                }
                div.textContent = sectionName;
                div.draggable = true;
                div.dataset.index = index;
                
                // Drag and drop event listeners
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);
                div.addEventListener('dragenter', handleDragEnter);
                div.addEventListener('dragleave', handleDragLeave);
                
                // Click to remove (with slight delay to avoid conflict with drag)
                div.addEventListener('click', (e) => {
                    if (!div.classList.contains('dragging')) {
                        setTimeout(() => removeFromArrangement(index), 100);
                    }
                });
                
                div.title = 'Drag to reorder, click to remove';
                container.appendChild(div);
            });

            if (arrangement.length === 0) {
                container.innerHTML = '<p style="opacity: 0.6; text-align: center; margin: 20px 0;">Click sections above to build your arrangement</p>';
            }
        }

        // Drag and drop handlers
        let draggedElement = null;
        let draggedIndex = null;

        function handleDragStart(e) {
            draggedElement = e.target;
            draggedIndex = parseInt(e.target.dataset.index);
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            if (e.target.classList.contains('arrangement-item') && e.target !== draggedElement) {
                e.target.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            if (e.target.classList.contains('arrangement-item')) {
                e.target.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            if (e.target.classList.contains('arrangement-item') && e.target !== draggedElement) {
                const targetIndex = parseInt(e.target.dataset.index);
                
                // Reorder arrangement array
                const draggedItem = arrangement[draggedIndex];
                arrangement.splice(draggedIndex, 1);
                arrangement.splice(targetIndex, 0, draggedItem);
                
                // Update current arrangement index if needed
                if (draggedIndex === currentArrangementIndex) {
                    currentArrangementIndex = targetIndex;
                } else if (draggedIndex < currentArrangementIndex && targetIndex >= currentArrangementIndex) {
                    currentArrangementIndex--;
                } else if (draggedIndex > currentArrangementIndex && targetIndex <= currentArrangementIndex) {
                    currentArrangementIndex++;
                }
                
                updateArrangementDisplay();
                autoSave();
            }
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.arrangement-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            draggedElement = null;
            draggedIndex = null;
        }

        // Remove from arrangement
        function removeFromArrangement(index) {
            arrangement.splice(index, 1);
            if (currentArrangementIndex >= arrangement.length) {
                currentArrangementIndex = 0;
            }
            updateArrangementDisplay();
            autoSave(); // Auto-save after modifying arrangement
        }

        // Clear arrangement
        function clearArrangement() {
            arrangement = [];
            currentArrangementIndex = 0;
            updateArrangementDisplay();
            autoSave(); // Auto-save after clearing arrangement
        }

        // Show templates menu
        function showTemplates() {
            const templates = [
                { name: 'Verse-Chorus', value: 'verse-chorus' },
                { name: 'Drum Groove', value: 'drum-groove' }, 
                { name: 'Fill Practice', value: 'fill-practice' },
                { name: 'Tempo Build', value: 'tempo-build' },
                { name: 'Jazz Standard', value: 'jazz-standard' },
                { name: 'Time Signatures', value: 'time-signatures' }
            ];
            
            const template = prompt('Select template:\n\n' + 
                templates.map((t, i) => `${i + 1}. ${t.name}`).join('\n') + 
                '\n\nEnter number (1-6):');
                
            const num = parseInt(template);
            if (num >= 1 && num <= templates.length) {
                loadPreset(templates[num - 1].value);
            }
        }

        // Clear all data function
        function clearAllData() {
            if (confirm('Clear all sections and arrangements? This cannot be undone.')) {
                sections = {};
                arrangement = [];
                updateSectionDisplay();
                updateArrangementDisplay();
                autoSave();
            }
        }

        // Load preset arrangement
        function loadPreset(type) {
            switch (type) {
                case 'verse-chorus':
                    // Create default sections if they don't exist
                    if (!sections['V']) {
                        sections['V'] = { tempo: 120, bars: 8, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'classic', accentSectionStart: false };
                    }
                    if (!sections['C']) {
                        sections['C'] = { tempo: 120, bars: 8, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'classic', accentSectionStart: false };
                    }
                    arrangement = ['V', 'V', 'C', 'V', 'C', 'C'];
                    break;
                
                case 'drum-groove':
                    sections['Kick'] = { tempo: 100, bars: 4, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 25, sound: 'deep', accentSectionStart: true };
                    sections['Snare'] = { tempo: 100, bars: 4, timeSignature: '4/4', subdivision: 2, subdivisionVolume: 30, sound: 'sharp', accentSectionStart: true };
                    sections['Hihat'] = { tempo: 100, bars: 4, timeSignature: '4/4', subdivision: 4, subdivisionVolume: 20, sound: 'classic', accentSectionStart: true };
                    sections['Ride'] = { tempo: 100, bars: 4, timeSignature: '4/4', subdivision: 3, subdivisionVolume: 25, sound: 'soft', accentSectionStart: true };
                    arrangement = ['Kick', 'Snare', 'Hihat', 'Ride', 'Kick', 'Snare'];
                    break;
                
                case 'fill-practice':
                    sections['Groove'] = { tempo: 110, bars: 7, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 25, sound: 'classic', accentSectionStart: false };
                    sections['Fill'] = { tempo: 110, bars: 1, timeSignature: '4/4', subdivision: 4, subdivisionVolume: 35, sound: 'sharp', accentSectionStart: true };
                    arrangement = ['Groove', 'Fill', 'Groove', 'Fill', 'Groove', 'Fill'];
                    break;
                
                case 'tempo-build':
                    sections['80bpm'] = { tempo: 80, bars: 8, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'deep', accentSectionStart: true };
                    sections['100bpm'] = { tempo: 100, bars: 8, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'classic', accentSectionStart: true };
                    sections['120bpm'] = { tempo: 120, bars: 8, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'sharp', accentSectionStart: true };
                    sections['140bpm'] = { tempo: 140, bars: 8, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'soft', accentSectionStart: true };
                    arrangement = ['80bpm', '100bpm', '120bpm', '140bpm'];
                    break;
                
                case 'limb-independence':
                    sections['R.Hand'] = { tempo: 90, bars: 4, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'classic', accentSectionStart: true };
                    sections['L.Hand'] = { tempo: 90, bars: 4, timeSignature: '4/4', subdivision: 2, subdivisionVolume: 25, sound: 'soft', accentSectionStart: true };
                    sections['R.Foot'] = { tempo: 90, bars: 4, timeSignature: '4/4', subdivision: 3, subdivisionVolume: 20, sound: 'deep', accentSectionStart: true };
                    sections['L.Foot'] = { tempo: 90, bars: 4, timeSignature: '4/4', subdivision: 4, subdivisionVolume: 15, sound: 'sharp', accentSectionStart: true };
                    arrangement = ['R.Hand', 'L.Hand', 'R.Foot', 'L.Foot', 'R.Hand', 'L.Hand'];
                    break;
                
                case 'gap-click':
                    sections['Click'] = { tempo: 100, bars: 1, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'classic', accentSectionStart: true };
                    sections['Gap'] = { tempo: 100, bars: 1, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'silent', accentSectionStart: false };
                    arrangement = ['Click', 'Gap', 'Click', 'Gap', 'Click', 'Gap', 'Click', 'Gap'];
                    break;
                
                case 'gap-click-short':
                    sections['Click3'] = { tempo: 100, bars: 3, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'classic', accentSectionStart: true };
                    sections['Gap1'] = { tempo: 100, bars: 1, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'silent', accentSectionStart: false };
                    arrangement = ['Click3', 'Gap1', 'Click3', 'Gap1', 'Click3', 'Gap1'];
                    break;
                
                case 'swing-practice':
                    sections['Straight'] = { tempo: 120, bars: 4, timeSignature: '4/4', subdivision: 2, subdivisionVolume: 25, sound: 'classic', accentSectionStart: true, swingFeel: false };
                    sections['Swing'] = { tempo: 120, bars: 4, timeSignature: '4/4', subdivision: 2, subdivisionVolume: 25, sound: 'soft', accentSectionStart: true, swingFeel: true };
                    sections['Shuffle'] = { tempo: 100, bars: 4, timeSignature: '4/4', subdivision: 4, subdivisionVolume: 20, sound: 'deep', accentSectionStart: true, swingFeel: true };
                    arrangement = ['Straight', 'Swing', 'Straight', 'Shuffle'];
                    break;
            }
            
            updateSectionDisplay();
            updateAvailableSections();
            updateArrangementDisplay();
            autoSave(); // Auto-save after loading preset
        }

        // Toggle playback
        function togglePlayback() {
            initAudio();
            
            if (isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        // Start playback
        function startPlayback() {
            if (arrangement.length === 0) {
                alert('Please create an arrangement first');
                return;
            }

            isPlaying = true;
            nextBeatTime = audioContext.currentTime;
            
            // Initialize count-in if enabled
            if (countInBars > 0) {
                isCountingIn = true;
                countInBar = 1;
                countInBeat = 1;
                // Don't initialize main arrangement yet
                playingArrangementIndex = 0;
                playingBar = 1;
                playingBeat = 1;
            } else {
                isCountingIn = false;
                currentArrangementIndex = 0;
                currentBar = 1;
                currentBeat = 1;
                playingArrangementIndex = 0;
                playingBar = 1;
                playingBeat = 1;
            }
            
            document.getElementById('playButton').textContent = '⏸ PAUSE';
            
            scheduler();
            schedulerTimer = setInterval(scheduler, lookahead);
            updateArrangementDisplay();
            updateVisualMetronome(); // Start breathing animation
        }

        // Stop playback
        function stopPlayback() {
            isPlaying = false;
            clearInterval(schedulerTimer);
            
            // Reset all playback state
            isCountingIn = false;
            countInBar = 1;
            countInBeat = 1;
            currentArrangementIndex = 0;
            currentBar = 1;
            currentBeat = 1;
            playingArrangementIndex = 0;
            playingBar = 1;
            playingBeat = 1;
            
            document.getElementById('playButton').textContent = '▶ PLAY';
            updateArrangementDisplay();
            updateStatus();
            
            // Stop breathing animation
            const flash = document.getElementById('metronomeFlash');
            flash.classList.remove('breathing', 'fast-tempo');
            updateVisualMetronome(); // Ensure correct size class
        }

        // Hamburger menu functions
        function toggleMenu() {
            const overlay = document.getElementById('menuOverlay');
            const panel = document.getElementById('menuPanel');
            
            overlay.classList.toggle('active');
            panel.classList.toggle('active');
        }

        function closeMenu() {
            const overlay = document.getElementById('menuOverlay');
            const panel = document.getElementById('menuPanel');
            
            overlay.classList.remove('active');
            panel.classList.remove('active');
        }

        // Initialize with example sections
        function init() {
            // Try to load previous state first
            autoLoad();
            
            // If no previous state, load defaults
            if (Object.keys(sections).length === 0) {
                sections = {
                    'A': { tempo: 120, bars: 4, timeSignature: '4/4', subdivision: 1, subdivisionVolume: 30, sound: 'classic', accentSectionStart: false },
                    'B': { tempo: 120, bars: 4, timeSignature: '4/4', subdivision: 3, subdivisionVolume: 30, sound: 'classic', accentSectionStart: false },
                    'C': { tempo: 120, bars: 4, timeSignature: '4/4', subdivision: 5, subdivisionVolume: 30, sound: 'classic', accentSectionStart: false }
                };
                arrangement = ['A', 'B', 'A', 'C'];
            }
            
            updateSectionDisplay();
            updateAvailableSections();
            updateArrangementDisplay();
            updateStatus();
            
            // Add volume slider update listeners
            const volumeSlider = document.getElementById('subdivisionVolume');
            const volumeDisplay = document.getElementById('subdivisionVolumeDisplay');
            volumeSlider.addEventListener('input', function() {
                volumeDisplay.textContent = this.value + '%';
            });

            // Global volume controls
            const globalMainVolumeSlider = document.getElementById('globalMainVolume');
            const globalMainVolumeDisplay = document.getElementById('globalMainVolumeDisplay');
            globalMainVolumeSlider.addEventListener('input', function() {
                globalMainVolume = parseInt(this.value);
                globalMainVolumeDisplay.textContent = this.value + '%';
            });

            const globalSubVolumeSlider = document.getElementById('globalSubVolume');
            const globalSubVolumeDisplay = document.getElementById('globalSubVolumeDisplay');
            globalSubVolumeSlider.addEventListener('input', function() {
                globalSubVolume = parseInt(this.value);
                globalSubVolumeDisplay.textContent = this.value + '%';
            });

            // Visual size control (now in hamburger menu)
            const visualSizeSelector = document.getElementById('visualSize');
            visualSizeSelector.addEventListener('change', function() {
                visualSize = this.value;
                updateVisualMetronome();
                localStorage.setItem('timecraft_visualSize', this.value);
            });

            // Count-in control
            const countInSelector = document.getElementById('countInBars');
            countInSelector.addEventListener('change', function() {
                countInBars = parseInt(this.value);
            });

            // Theme selector (now in hamburger menu)
            const themeSelector = document.getElementById('themeSelector');
            themeSelector.addEventListener('change', function() {
                setTheme(this.value);
            });

            // Load saved theme and visual size
            const savedTheme = localStorage.getItem('timecraft_theme') || 'dark';
            const savedVisualSize = localStorage.getItem('timecraft_visualSize') || 'normal';
            
            setTheme(savedTheme);
            themeSelector.value = savedTheme;
            visualSize = savedVisualSize;
            visualSizeSelector.value = savedVisualSize;

            // Initialize visual metronome
            updateVisualMetronome();
        }

        // Section Builder collapse/expand functionality
        function toggleSectionBuilder() {
            const panel = document.getElementById('sectionBuilderPanel');
            const button = panel.querySelector('.collapse-btn');
            
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                button.textContent = '−';
            } else {
                panel.classList.add('collapsed');
                button.textContent = '+';
            }
        }

        // Arrangement Builder collapse/expand functionality
        function toggleArrangementBuilder() {
            const panel = document.getElementById('arrangementBuilderPanel');
            const button = panel.querySelector('.collapse-btn');
            
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                button.textContent = '−';
            } else {
                panel.classList.add('collapsed');
                button.textContent = '+';
            }
        }

        // Toggle between setup and performance modes
        function toggleMode() {
            isPerformanceMode = !isPerformanceMode;
            const body = document.body;
            const button = document.getElementById('modeToggle');
            
            if (isPerformanceMode) {
                body.classList.add('performance-mode');
                button.textContent = '⚙️ Setup Mode';
                button.style.background = '#4CAF50';
            } else {
                body.classList.remove('performance-mode');
                button.textContent = '📱 Performance Mode';
                button.style.background = '#9C27B0';
            }
            
            updateVisualMetronome();
        }

        // Keyboard shortcuts
        function handleKeyboardShortcuts(event) {
            // Don't trigger shortcuts when typing in input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT') {
                return;
            }
            
            switch (event.code) {
                case 'Space':
                    event.preventDefault();
                    togglePlayback();
                    break;
                    
                case 'ArrowUp':
                    event.preventDefault();
                    adjustTempo(event.shiftKey ? 10 : 5);
                    break;
                    
                case 'ArrowDown':
                    event.preventDefault();
                    adjustTempo(event.shiftKey ? -10 : -5);
                    break;
                    
                case 'ArrowLeft':
                    event.preventDefault();
                    if (isPlaying) jumpToArrangementPosition(-1);
                    break;
                    
                case 'ArrowRight':
                    event.preventDefault();
                    if (isPlaying) jumpToArrangementPosition(1);
                    break;
                    
                case 'KeyM':
                    event.preventDefault();
                    toggleMode();
                    break;
                    
                case 'KeyT':
                    event.preventDefault();
                    tapTempo();
                    break;
                    
                case 'KeyN':
                    event.preventDefault();
                    if (!isPerformanceMode) {
                        document.getElementById('sectionName').focus();
                    }
                    break;
                    
                case 'KeyC':
                    event.preventDefault();
                    if (!isPerformanceMode) {
                        clearArrangement();
                    }
                    break;
                    
                // Number keys 1-9 for quick arrangement jumping
                case 'Digit1':
                case 'Digit2':
                case 'Digit3':
                case 'Digit4':
                case 'Digit5':
                case 'Digit6':
                case 'Digit7':
                case 'Digit8':
                case 'Digit9':
                    event.preventDefault();
                    const position = parseInt(event.code.replace('Digit', '')) - 1;
                    if (isPlaying && position < arrangement.length) {
                        jumpToArrangementPosition(position, true);
                    }
                    break;
            }
        }

        // Adjust tempo of current section or first section
        function adjustTempo(delta) {
            let targetSection = null;
            
            if (editingSection && sections[editingSection]) {
                targetSection = editingSection;
            } else if (isPlaying && arrangement.length > 0) {
                targetSection = arrangement[currentArrangementIndex];
            } else if (Object.keys(sections).length > 0) {
                targetSection = Object.keys(sections)[0];
            }
            
            if (targetSection && sections[targetSection]) {
                const newTempo = Math.max(40, Math.min(220, sections[targetSection].tempo + delta));
                sections[targetSection].tempo = newTempo;
                
                // Update form if editing
                if (editingSection === targetSection) {
                    document.getElementById('sectionTempo').value = newTempo;
                }
                
                updateSectionDisplay();
                updateStatus();
                autoSave();
                
                // Show tempo change feedback
                showTempoFeedback(targetSection, newTempo, delta);
            }
        }

        // Jump to specific arrangement position
        function jumpToArrangementPosition(delta, absolute = false) {
            if (!isPlaying || arrangement.length === 0) return;
            
            let newIndex;
            if (absolute) {
                newIndex = delta;
            } else {
                newIndex = currentArrangementIndex + delta;
            }
            
            // Wrap around arrangement
            if (newIndex < 0) {
                newIndex = arrangement.length - 1;
            } else if (newIndex >= arrangement.length) {
                newIndex = 0;
            }
            
            // Update current position
            currentArrangementIndex = newIndex;
            currentBar = 1;
            currentBeat = 1;
            
            // Reset next beat time to current time for immediate effect
            nextBeatTime = audioContext.currentTime;
            
            updateArrangementDisplay();
            updateStatus();
        }

        // Show tempo adjustment feedback
        function showTempoFeedback(sectionName, newTempo, delta) {
            const direction = delta > 0 ? '↑' : '↓';
            const amount = Math.abs(delta);
            
            // Create temporary feedback element
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-weight: 600;
                z-index: 1000;
                animation: fadeInOut 2s ease-in-out;
            `;
            feedback.textContent = `${sectionName}: ${newTempo} BPM ${direction}${amount}`;
            
            // Add fade animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translateY(-10px); }
                    20% { opacity: 1; transform: translateY(0); }
                    80% { opacity: 1; transform: translateY(0); }
                    100% { opacity: 0; transform: translateY(-10px); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(feedback);
            
            setTimeout(() => {
                document.body.removeChild(feedback);
                document.head.removeChild(style);
            }, 2000);
        }

        // Theme management
        function setTheme(themeName) {
            const validThemes = ['dark', 'light', 'contrast', 'stage'];
            if (!validThemes.includes(themeName)) {
                themeName = 'dark';
            }
            
            // Remove existing theme classes
            document.body.removeAttribute('data-theme');
            
            // Set new theme (dark is default, no data-theme needed)
            if (themeName !== 'dark') {
                document.body.setAttribute('data-theme', themeName);
            }
            
            // Save theme preference
            localStorage.setItem('timecraft_theme', themeName);
            
            // Update metronome for theme-specific styling
            updateVisualMetronome();
        }

        // Add keyboard event listener
        document.addEventListener('keydown', handleKeyboardShortcuts);

        // PWA Service Worker Registration
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then((registration) => {
                            console.log('Service Worker registered successfully:', registration.scope);
                            
                            // Check for updates
                            registration.addEventListener('updatefound', () => {
                                const newWorker = registration.installing;
                                newWorker.addEventListener('statechange', () => {
                                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                        // New version available
                                        showUpdateNotification();
                                    }
                                });
                            });
                        })
                        .catch((error) => {
                            console.log('Service Worker registration failed:', error);
                        });
                });
            }
        }

        // Show update notification
        function showUpdateNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #4CAF50;
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: 600;
                cursor: pointer;
            `;
            notification.innerHTML = `
                🔄 New version available! 
                <span style="text-decoration: underline;">Tap to update</span>
            `;
            
            notification.onclick = () => {
                window.location.reload();
            };
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 10000);
        }

        // PWA Install Prompt
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWA install prompt available');
            e.preventDefault();
            deferredPrompt = e;
            showInstallButton();
        });

        // Debug: Check PWA install criteria
        window.addEventListener('load', () => {
            setTimeout(() => {
                console.log('PWA Debug Info:');
                console.log('- Service Worker:', 'serviceWorker' in navigator);
                console.log('- HTTPS:', location.protocol === 'https:');
                console.log('- Standalone:', window.matchMedia('(display-mode: standalone)').matches);
                console.log('- Install prompt received:', !!deferredPrompt);
                
                // Show install button manually if criteria are met but prompt didn't fire
                if (!deferredPrompt && 'serviceWorker' in navigator && location.protocol === 'https:') {
                    console.log('Manually showing install button for testing');
                    showManualInstallButton();
                }
            }, 3000);
        });

        function showInstallButton() {
            // Only show if not already installed
            if (!window.matchMedia('(display-mode: standalone)').matches) {
                const installButton = document.createElement('button');
                installButton.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #2196F3;
                    color: white;
                    border: none;
                    border-radius: 50px;
                    padding: 15px 20px;
                    font-size: 14px;
                    font-weight: 600;
                    cursor: pointer;
                    box-shadow: 0 4px 12px rgba(33,150,243,0.4);
                    z-index: 1000;
                    animation: pulse 2s infinite;
                `;
                installButton.innerHTML = '📱 Install App';
                
                // Add pulse animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes pulse {
                        0% { transform: scale(1); }
                        50% { transform: scale(1.05); }
                        100% { transform: scale(1); }
                    }
                `;
                document.head.appendChild(style);
                
                installButton.onclick = async () => {
                    if (deferredPrompt) {
                        deferredPrompt.prompt();
                        const { outcome } = await deferredPrompt.userChoice;
                        console.log('Install prompt result:', outcome);
                        deferredPrompt = null;
                        installButton.remove();
                        style.remove();
                    }
                };
                
                document.body.appendChild(installButton);
                
                // Auto-hide after 30 seconds
                setTimeout(() => {
                    if (installButton.parentNode) {
                        installButton.remove();
                        style.remove();
                    }
                }, 30000);
            }
        }

        // Manual install button for browsers that don't show automatic prompt
        function showManualInstallButton() {
            const installButton = document.createElement('button');
            installButton.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: #FF9800;
                color: white;
                border: none;
                border-radius: 50px;
                padding: 15px 20px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 4px 12px rgba(255,152,0,0.4);
                z-index: 1000;
            `;
            installButton.innerHTML = '📱 Add to Home Screen';
            
            installButton.onclick = () => {
                alert('To install TimeCraft:\n\n• Android Chrome: Menu → "Add to Home screen"\n• iOS Safari: Share → "Add to Home Screen"');
            };
            
            document.body.appendChild(installButton);
            
            // Auto-hide after 45 seconds
            setTimeout(() => {
                if (installButton.parentNode) {
                    installButton.remove();
                }
            }, 45000);
        }

        // Handle app installation
        window.addEventListener('appinstalled', (evt) => {
            console.log('TimeCraft PWA was installed');
            // Remove install button if present
            const installButtons = document.querySelectorAll('button');
            installButtons.forEach(btn => {
                if (btn.innerHTML.includes('Install') || btn.innerHTML.includes('Add to Home')) {
                    btn.remove();
                }
            });
        });

        // Register service worker
        registerServiceWorker();

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>